import unittest
from src.kernelpop import *

from exploits.linux.CVE20177308 import CVE20177308
from exploits.linux.CVE20171000379 import CVE20171000379

class TestGetKernelVersion(unittest.TestCase):

	# def potentially_vulnerable(kernel_version, exploit_module):
	def test_new_kernel_not_vulnerable(self):
		test_uname = "Linux atlantic 4.9.0-4-amd64 #1 SMP Debian 4.9.65-3+deb9u1 (2017-12-23) x86_64 GNU/Linux"
		test_kernel = get_kernel_version(uname=test_uname)
		test_exploit = CVE20177308()
		exploit_results = potentially_vulnerable(test_kernel, test_exploit)
		self.assertEqual(NOT_VULNERABLE, exploit_results)

	# TODO: this is failing because the parsed distro is DEBIAN_GENERIC, whereas the exploit distro is
	# TODO: 	DEBIAN_9, DEBIAN_8, etc.
	# TODO: possible fix is to add some version guessing based on kernel version?, could be sketchy though.
	# TODO:		also, we could only guess exactly for debian, ubuntu screws things up with LTS
	def test_should_be_vulnerable(self):
		test_uname = "Linux atlantic 4.9.0-4-amd64 #1 SMP Debian 4.9.65-3+deb9u1 (2017-12-23) x86_64 GNU/Linux"
		test_kernel = get_kernel_version(uname=test_uname)
		test_exploit = CVE20171000379()
		exploit_results = potentially_vulnerable(test_kernel, test_exploit)
		self.assertEqual(EXPLOIT_AVAILABLE, exploit_results)

	def test_new_kernel_no_found_exploits(self):
		test_uname = "Linux atlantic 4.9.0-4-amd64 #1 SMP Debian 4.9.65-3+deb9u1 (2017-12-23) x86_64 GNU/Linux"
		test_kernel = get_kernel_version(uname=test_uname)
		exploit_results = find_exploit_locally(test_kernel)
		self.assertTrue(total_exploits(exploit_results) == 0)


if __name__ == "__main__":
	unittest.main()
